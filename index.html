<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>SVG-based Puzzle</title>
        <style>
            #svg-image {
                max-width: 100%;
                background: #fcfffc;
                display: block;
                margin: auto;
            }
            .puzzle-line {
                fill: magenta;
                stroke-width: 3;
                stroke: blue;
                fill-opacity: 0;
            }
            .puzzle-piece:hover .puzzle-line {
                fill-opacity: .2;
            }
        </style>
    </head>
    <body>

        <svg id="svg-image">
            <defs id="svg-defs">
                <image id="puzzle-image" href="lisbon.jpg" />
                <path id="puzzle-piece" d="M10,10 h20v20h-20 C10,15,5,30,5,20C5,10,10,25,10,10 z" />
                <clipPath id="puzzle-clip">
                    <use href="#puzzle-piece" />
                </clipPath>
            </defs>
            <rect id="background-canvas" fill="#e0f0e0" />
            <g id="all-pieces"></g>
            
        </svg>
        <script>
            const SVG_IMAGE = document.getElementById('svg-image'),
                BASE_WIDTH = 150,
                BASE_HEIGHT = 150,
                MARGIN = 100,
                WIDTH_COUNT = 6,
                HEIGHT_COUNT = 4,
                IMAGE_WIDTH = BASE_WIDTH * WIDTH_COUNT,
                IMAGE_HEIGHT = BASE_HEIGHT * HEIGHT_COUNT,
                VP_WIDTH = IMAGE_WIDTH + 2 * MARGIN,
                VP_HEIGHT = IMAGE_HEIGHT + 2 * MARGIN,
                BG_CANVAS = document.getElementById('background-canvas'),
                IMAGE_ELEMENT = document.getElementById('puzzle-image');
            SVG_IMAGE.setAttribute('width', VP_WIDTH);
            SVG_IMAGE.setAttribute('height', VP_HEIGHT);
            SVG_IMAGE.setAttribute('viewBox', `${-MARGIN} ${-MARGIN} ${VP_WIDTH} ${VP_HEIGHT}`);
            BG_CANVAS.setAttribute('width', IMAGE_WIDTH);
            BG_CANVAS.setAttribute('height', IMAGE_HEIGHT);
            IMAGE_ELEMENT.setAttribute('width', IMAGE_WIDTH);
            IMAGE_ELEMENT.setAttribute('height', IMAGE_HEIGHT);
            
            let puzzle_vertical_positions = [];
            for (let x = 0; x < WIDTH_COUNT - 1; x++) {
                let col = [];
                for (let y = 0; y < HEIGHT_COUNT; y++) {
                    col.push([
                        2*Math.floor(2*Math.random()) + .6*Math.random() - 1.3,
                        .4 * Math.random() - .2
                    ]);
                }
                puzzle_vertical_positions.push(col);
            }
            let puzzle_horizontal_positions = [];
            for (let x = 0; x < WIDTH_COUNT; x++) {
                let col = [];
                for (let y = 0; y < HEIGHT_COUNT - 1; y++) {
                    col.push([
                        2*Math.floor(2*Math.random()) + .6*Math.random() - 1.3,
                        .4 * Math.random() - .2
                ]);
                }
                puzzle_horizontal_positions.push(col);
            }

            let def_paths = '',
                tile_shuffler = [];

            for (let x = 0; x < WIDTH_COUNT; x++) {
                for (let y = 0; y < HEIGHT_COUNT; y++) {
                    let top = y * BASE_HEIGHT,
                        left = x * BASE_WIDTH,
                        bottom = top + BASE_HEIGHT,
                        right = left + BASE_WIDTH,
                        centre_x = (left + right) / 2,
                        centre_y = (top + bottom) / 2;
                    let d = `M${left},${top}`;
                    if (y) {
                        let top_notch = top + BASE_HEIGHT/4 * puzzle_horizontal_positions[x][y-1][0],
                            notch_centre = centre_x + BASE_WIDTH * puzzle_horizontal_positions[x][y-1][1];
                        d += `C${(right*2+notch_centre)/3},${top*2-top_notch},${left},${top_notch},${notch_centre},${top_notch}`
                            + `C${right},${top_notch},${(left*2+notch_centre)/3},${top*2-top_notch},${right},${top}`;
                    } else {
                        d += `L${right},${top}`;
                    }
                    if (x < (WIDTH_COUNT - 1)) {
                        let right_notch = right + BASE_WIDTH/4 * puzzle_vertical_positions[x][y][0],
                            notch_centre = centre_y + BASE_HEIGHT * puzzle_vertical_positions[x][y][1];
                        d += `C${right*2-right_notch},${(bottom*2+notch_centre)/3},${right_notch},${top},${right_notch},${notch_centre}`
                            + `C${right_notch},${bottom},${right*2-right_notch},${(top*2+notch_centre)/3},${right},${bottom}`;
                    } else {
                        d += `L${right},${bottom}`
                    }
                    if (y < (HEIGHT_COUNT - 1)) {
                        let bottom_notch = bottom + BASE_HEIGHT/4 * puzzle_horizontal_positions[x][y][0],
                            notch_centre = centre_x + BASE_WIDTH *  puzzle_horizontal_positions[x][y][1];
                        d += `C${(left*2+notch_centre)/3},${bottom*2-bottom_notch},${right},${bottom_notch},${notch_centre},${bottom_notch}`
                            + `C${left},${bottom_notch},${(right*2+notch_centre)/3},${bottom*2-bottom_notch},${left},${bottom}`;
                    } else {
                        d += `L${left},${bottom}`;
                    }
                    if (x) {
                        let left_notch = left + BASE_WIDTH/4 * puzzle_vertical_positions[x-1][y][0],
                            notch_centre = centre_y + BASE_HEIGHT * puzzle_vertical_positions[x-1][y][1];
                        d += `C${left*2-left_notch},${(top*2+notch_centre)/3},${left_notch},${bottom},${left_notch},${notch_centre}`
                        + `C${left_notch},${top},${left*2-left_notch},${(bottom*2+notch_centre)/3},${left},${top}`;
                    } else {
                        d += `z`;
                    }
                    
                    def_paths += `<path id="puzzle-path-${x}-${y}" d="${d}" />
                        <clipPath id="puzzle-clip-${x}-${y}"><use href="#puzzle-path-${x}-${y}" />
                    </clipPath>`;

                    tile_shuffler.push([`${x}-${y}`, centre_x, centre_y]);

                }
            }

            let margin_shuffler = [],
                square_count = WIDTH_COUNT * HEIGHT_COUNT,
                linear_length = 2 * (WIDTH_COUNT + HEIGHT_COUNT);
            for (let i = 0; i < square_count; i++) {
                let linear_position = linear_length * (i + .5) / square_count;
                if (linear_position < WIDTH_COUNT) {
                    margin_shuffler.push([linear_position * BASE_WIDTH, 0]);
                    continue;
                }
                if (linear_position < (WIDTH_COUNT + HEIGHT_COUNT)) {
                    margin_shuffler.push([0, (linear_position - WIDTH_COUNT) * BASE_HEIGHT]);
                    continue;
                }
                if (linear_position < (2 * WIDTH_COUNT + HEIGHT_COUNT)) {
                    margin_shuffler.push([(linear_position - WIDTH_COUNT - HEIGHT_COUNT) * BASE_WIDTH, IMAGE_HEIGHT]);
                    continue;
                }
                margin_shuffler.push([IMAGE_WIDTH, (linear_position - 2 * WIDTH_COUNT - HEIGHT_COUNT) * BASE_HEIGHT]);
            }

            let all_pieces = '';

            while (tile_shuffler.length) {
                let tile_info = tile_shuffler.splice(Math.floor(Math.random()*tile_shuffler.length),1)[0],
                    margin_info = margin_shuffler.splice(Math.floor(Math.random()*margin_shuffler.length),1)[0],
                    tile_ref = tile_info[0],
                    trans_x = margin_info[0] - tile_info[1],
                    trans_y = margin_info[1] - tile_info[2];
                
                all_pieces += `<g id="puzzle-piece-${tile_ref}" class="puzzle-piece" transform="translate(${trans_x}, ${trans_y})">
                    <g class="puzzle-image" clip-path="url(#puzzle-clip-${tile_ref})">
                        <use href="#puzzle-image" />
                    </g>
                    <use class="puzzle-line" href="#puzzle-path-${tile_ref}" />
                    </g>`;
            }

            document.getElementById('svg-defs').innerHTML += def_paths;
            document.getElementById('all-pieces').innerHTML += all_pieces;

            let moving_tile = null,
                tile_start_x = 0,
                tile_start_y = 0,
                pointer_start_x = 0,
                pointer_start_y = 0;
            
            function getCoords() {
                let res = moving_tile.getAttribute('transform').split(/[(),\s]/).filter(n => !isNaN(parseInt(n)));
                if (res.length < 2) {
                    return [0, 0];
                } else {
                    return res;
                }
            }

            function startMovement(el, x, y) {
                moving_tile = el;
                let coords = getCoords(),
                    line = moving_tile.querySelector('use.puzzle-line');
                line.setAttribute('stroke', 'red');
                tile_start_x = parseInt(coords[0]);
                tile_start_y = parseInt(coords[1]);
                pointer_start_x = x;
                pointer_start_y = y;
            }

            function continueMovement(x, y) {
                let scale = SVG_IMAGE.clientWidth / VP_WIDTH;
                    new_x = (x - pointer_start_x) / scale + tile_start_x,
                    new_y = (y - pointer_start_y) / scale + tile_start_y;
                moving_tile.setAttribute('transform',`translate(${new_x},${new_y})`);
            }

            function endMovement() {
                if (moving_tile) {
                    let coords = getCoords(),
                        line = moving_tile.querySelector('use.puzzle-line');
                    if ((coords[0]**2 + coords[1]**2) < 25 ) {
                        moving_tile.setAttribute('transform', '');
                        line.setAttribute('stroke', 'none');
                    } else {
                        line.setAttribute('stroke', 'blue');
                    }
                }
                moving_tile = null;
            }

            Array.from(document.querySelectorAll('g.puzzle-piece')).forEach(el => {
                el.addEventListener("mousedown", ev => {
                    startMovement(el, ev.clientX, ev.clientY);
                    ev.preventDefault();
                });
                el.addEventListener("touchstart", ev => {
                    if (ev.touches.length === 1) {
                        startMovement(el, ev.touches[0].clientX, ev.touches[0].clientY);
                        ev.preventDefault();
                    }
                });
            });

            document.addEventListener("mousemove", ev => {
                if (moving_tile) {
                    continueMovement(ev.clientX, ev.clientY);
                    ev.preventDefault();
                }
            });
            
            document.addEventListener("touchmove", ev => {
                if (moving_tile && ev.touches.length === 1) {
                    continueMovement(ev.touches[0].clientX, ev.touches[0].clientY);
                    ev.preventDefault();
                }
            });
            
            document.addEventListener("mouseup", endMovement);
            document.addEventListener("touchend", endMovement);

        </script>
    </body>
</html>